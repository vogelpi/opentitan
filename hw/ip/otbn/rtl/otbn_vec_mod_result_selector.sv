// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

/**
 * Vectorized Modulo Result Selector
 *
 * This module implements the result selection for vectorized pseudo-additions and subtractions.
 *
 * The otbn_alu_bignum calculates pseudo modulo addition and subtraction by using two adders and
 * evaluating the carry bits. Depending on the carry bits adder X or Y is selected as result.
 *
 * For addtion:
 * - Adder X calculates X = a + b
 * - Adder Y calculates Y = X - mod
 * If X generates a carry: a+b > mod (mod is 256b) -> Select Y as result
 * If Y generates a carry: X-mod = (a+b) - mod >= 0 hence a+b >= mod -> Select Y as result
 * If no carry is generated -> Select X as result
 *
 * For subtraction:
 * - Adder X calculates X = a - b
 * - Adder Y calculates Y = X + mod
 * If X generates a carry: a - b >= 0 -> Select X as result
 * Else: a - b < 0 and thus select Y = a - b + mod as result
 *
 * For vectorized calculations this selection must be performed for each vector element
 * independently. The otbn_alu_bignum's vectorized adder (otbn_vec_adder) outputs the whole vector
 * and carry bits of each vector chunk. This module now selects for each vector element the
 * correct result part of adder X or Y depending on the carry bit of the given element length.
 * The input carry bits must be the vector chunks' carry bit and not the elements' carry bit.
 *
 * Internally the selection process is split up into a decision and selection stage.
 *
 * Decision Stage:
 * The decision stages compute the decisions for each vector chunk separately and thus independent
 * of the vector element length. The decision depends on the operation (addvm / subvm) as
 * described above.
 *
 * Selection Stage:
 * The final result is selected based on the decision bits and the configured element length.
 * The element length selects the appropriate decision bit for each result chunk.
 * E.g. for a vector chunk size of 16b and 32b vector elements the result bits [15:0] and [31:16]
 * are controlled by the decision bit D1 which is generated by the carries of the 2nd 16b results 
 * (CX1, CY1).
 *
 * X0 = X[15:0], X1 = X[31:16], ..., X15 = X[255:240], same for Y
 * Di = Decision by carry bits Cyi and CYi
 *
 * D15                          D15 D14                             D15 D7 D3 D1 D0
 *  |                            |   |                               |  |  |  |  |
 *  |                          \-------/                           \---------------/
 *  |         Y15 X15   ELEN -->\-----/      Y14 X14   ...  ELEN -->\-------------/   Y0  X0
 *  |          |   |               |          |   |                        |          |   |
 *  |        \-------/             |        \-------/                      |        \-------/
 *  +-------->\-1-0-/              +-------->\-1-0-/                       +-------->\-1-0-/
 *  res_sel15    |                 res_sel14    |                          res_sel0     |
 *               |                              |                                       |
 *         res[255:240]                   res[239:224]                             res[15:0]
 *
 * TODO: Blanking is required for the ELEN dependent MUXs controlling the res_seli value.
 */

module otbn_vec_mod_result_selector
  import otbn_pkg::*;
(
  input  logic [VLEN-1:0]     result_x_i,
  input  logic [NVecProc-1:0] carries_x_i,
  input  logic [VLEN-1:0]     result_y_i,
  input  logic [NVecProc-1:0] carries_y_i,
  input  logic                is_subtraction_i,
  input  elen_bignum_e        elen_i,


  output logic [VLEN-1:0]     result_o
);
  ////////////////////
  // Decision stage //
  ////////////////////

  logic [NVecProc-1:0] decision;

  // MUX control signal must be blankable
  always_comb begin
    if (is_subtraction_i == 1'b1) begin
      decision = ~carries_x_i;
    end else begin
      decision = carries_x_i | carries_y_i;
    end
  end

  /////////////////////
  // Selection stage //
  /////////////////////
  // TODO: MUX control signals must be blankable? Check this
  // TODO: What and how to blank?
  logic [NvecProc-1:0] res_sel;

  // TODO: Make dynamic depending on VLEN, NVecProc, VChunkLEN
  always_comb begin
    unique case (elen_i)
      VecElen16: begin // res_sel0 = D0, res_sel1 = D1, ...
        res_sel = decision;
      end
      VecElen32: begin // res_sel{0,1} = D1, res_sel{2,3} = D3, ...
        for (int i_chunk = 0; i_chunk < NVecProc; i_chunk+=2) begin : g_selection_32b
          res_sel[i_chunk+:2] = {2{decision[i_chunk+1]}};
        end
      end
      VecElen64: begin // res_sel{0,1,2,3} = D3, res_sel{4,5,6,7} = D7, ...
        for (int i_chunk = 0; i_chunk < NVecProc; i_chunk+=4) begin : g_selection_32b
          res_sel[i_chunk+:4] = {4{decision[i_chunk+3]}};
        end
      end
      VecElen128: begin // res_sel{0 .. 7} = D7, res_sel{8 .. 15} = D15
        res_sel[0+:8] = {8{decision[7]}};
        res_sel[8+:8] = {8{decision[15]}};
      end
      VecElen256: begin
        res_sel = {16{decision[15]}};
      end
    endcase
  end

  for (genvar i_res = 0; i_res < NVecProc; i_res++) begin : g_assign_results
    assign result_o[i_res*VChunkLEN+:VChunkLEN] =
                                          res_sel[i_res] ? result_y_i[i_res*VChunkLEN+:VChunkLEN]
                                                         : result_x_i[i_res*VChunkLEN+:VChunkLEN];
  end

endmodule
