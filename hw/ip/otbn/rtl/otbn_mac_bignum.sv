// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

`include "prim_assert.sv"
/**
 * OTBN Bignum MAC which supports vectorized (modulo) multiplication
 * This module implements the multiply and accumulate functionality. It also supports vectorized
 * multiplication of 16b or 32b elements and optional modulo reduction. The vector elements are
 * stored in a WDR. The vector is processed in 64b chunks. These chunks can be interpreted as four
 * 16-bit or two 32-bit multiplications. For modulo reduction the Montgomery algorithm is
 * implemented.
 * The multiplications are performed using a vectorized multiplier which sums the partial products
 * of a 64b multiplication depending on the selected element width (see otbn_vec_multiplier.sv).
 * Regular MAC functionality is performed combinatorially. The vectorized multiplication requires
 * 4 cycles (4x 64b) and the modulo multiplication requires 12 cycles (see below).
 *
 * The ACC register is used to store the intermediate results of the vectorized multiplications.
 * The vectorized multiplications can operate elementwise or multiply vector a with a selected
 * index of vector b. The later mode is called "lane mode".
 *
 * The Montgomery algorithmus efficiently computes a multiplication and reduces it by a modulus.
 * The inputs however must be pretransformed into Montgomery space: a_ = a * 2^d mod q.
 *
 * When using NTT / iNTT we can postpone the transformation of one operand to the iNTT. In the iNTT
 * the transformation can be merged into the multiplication with n^(-1) at the end of the iNTT.
 * This trick is enabled by the linearity of the NTT and INTT.
 *
 * Inputs:
 * - a, b: Operands in [0, q[
 * - d:   Bitwith of operands
 * - q:   Modulus in ]0, 2^d]
 * - R:   Montgomery constant, precomputed, R = (-q)^(-1) mod 2^d
 * Outputs:
 * - r = a*b * 2^(-d) mod q and r in [0,q[
 * - c = a*b
 * Algorithm (where []_d are the lower d bits, []^d are the higher d bits)
 *   r = [c + [[c]_d * R]_d * q]^d
 *   if r >= q then
 *       return r - q
 *   return r
 *
 * To save area the the Montgomery algorithmus is split over 3 cycles to reuse the multiplier:
 * Cycle 0:  Reg(Tmp) = 0, Reg(C) = 0
 * Cycle 1:  Reg(Tmp) = [a*b]_d,     Reg(C) = a*b
 * Cycle 2:  Reg(Tmp) = [Tmp*R]_d,   Reg(C) = a*b
 * Cycle 3:  Output   = c + (Tmp)*q mod q = [c + (Tmp)*q]^d (-q)
 *
 * The required constants q and R are expected to be in the MOD WSR at following locations:
 * For 16b: q @ [15:0], R @ [47:32]
 * For 32b: q @ [31:0], R @ [63:32]
 *
 * The multiplier and adders are vectorized allowing us to compute four 16b or two 32b values at
 * once. Thus for processing the 256b vector (with 16 16b or 8 32b elements) we require
 * 4*3 = 12 cycles. All control signals are generated by a internal state machine. The result of
 * each 64b chunk is stored in the bignum MAC module's register ACC.
 */
module otbn_mac_bignum
  import otbn_pkg::*;
(
  input logic clk_i,
  input logic rst_ni,

  input mac_bignum_operation_t operation_i,
  input logic                  mac_en_i,
  input logic                  mac_commit_i,

  output logic [WLEN-1:0] operation_result_o,
  output logic            operation_valid_o,
  output flags_t          operation_flags_o,
  output flags_t          operation_flags_en_o,
  output logic            operation_intg_violation_err_o,

  input  mac_predec_bignum_t mac_predec_bignum_i,
  output logic               predec_error_o,

  input  logic [WLEN-1:0] urnd_data_i,
  input  logic            sec_wipe_acc_urnd_i,
  input  logic            sec_wipe_tmp_urnd_i,
  input  logic            sec_wipe_c_urnd_i,
  input  logic            sec_wipe_running_i,
  output logic            sec_wipe_err_o,

  output logic [ExtWLEN-1:0] ispr_acc_intg_o,
  input  logic [ExtWLEN-1:0] ispr_acc_wr_data_intg_i,
  input  logic               ispr_acc_wr_en_i,

  input  logic [ExtWLEN-1:0] ispr_mod_intg_i
);
  localparam int HWLEN    = WLEN / 2;
  localparam int ExtHWLEN = HWLEN * 39 / 32;
  localparam int BaseWordsPerHWLEN = HWLEN / 32;

  localparam int QWLEN    = WLEN / 4;
  localparam int ExtQWLEN = QWLEN * 39 / 32;
  localparam int BaseWordsPerQWLEN = QWLEN / 32;

  typedef enum logic [1:0] {
    MulOpB,
    MulOpR,
    MulOpq
  } mul_op_b_sel_e;

  // Enum for value indexing
  typedef enum logic {
    ModVecElen16 = 1'b0,
    ModVecElen32 = 1'b1
  } mod_vec_elen_e;

  // Encoding generated with:
  // $ ./util/design/sparse-fsm-encode.py -d 3 -m 16 -n 8 \
  //     -s 5799399942 --language=sv
  //
  // Hamming distance histogram:
  //
  //  0: --
  //  1: --
  //  2: --
  //  3: ||||||||||||||||| (30.83%)
  //  4: |||||||||||||||||||| (35.83%)
  //  5: ||||||||| (17.50%)
  //  6: |||||| (10.83%)
  //  7: || (5.00%)
  //  8: --
  //
  // Minimum Hamming distance: 3
  // Maximum Hamming distance: 7
  // Minimum Hamming weight: 2
  // Maximum Hamming weight: 6
  //
  localparam int StateMacWidth = 8;
  typedef enum logic [StateMacWidth-1:0] {
    MacRegular       = 8'b00100011, // inlcudes: MacStartQW0, MacStartModQW0C0
    MacQW1           = 8'b01010000,
    MacQW2           = 8'b10010100,
    MacDoneQW        = 8'b10011001,
    MacModQW0C1      = 8'b11001110,
    MacModQW0C2      = 8'b01101010,
    MacModQW1C0      = 8'b10101100,
    MacModQW1C1      = 8'b00001101,
    MacModQW1C2      = 8'b11101001,
    MacModQW2C0      = 8'b01100100,
    MacModQW2C1      = 8'b11110110,
    MacModQW2C2      = 8'b00010111,
    MacModQW3C0      = 8'b01111101,
    MacModQW3C1      = 8'b11000101,
    MacDoneModQW3C2  = 8'b10111010,
    MacError         = 8'b01011011
  } mac_state_e;

  mac_state_e mac_state_d, mac_state_q;

  //////////////////
  // ACC Register //
  //////////////////
  logic                          acc_wr_en;
  logic [ExtWLEN-1:0]            acc_intg_d;
  logic [ExtWLEN-1:0]            acc_intg_q;
  logic [ExtWLEN-1:0]            acc_intg_calc;
  logic [WLEN-1:0]               acc_no_intg_d;
  logic [WLEN-1:0]               acc_no_intg_q;
  logic [2*BaseWordsPerWLEN-1:0] acc_intg_err;
  for (genvar i_word = 0; i_word < BaseWordsPerWLEN; i_word++) begin : g_acc_words
    prim_secded_inv_39_32_enc i_secded_enc (
      .data_i(acc_no_intg_d[i_word*32+:32]),
      .data_o(acc_intg_calc[i_word*39+:39])
    );
    prim_secded_inv_39_32_dec i_secded_dec (
      .data_i    (acc_intg_q[i_word*39+:39]),
      .data_o    (/* unused because we abort on any integrity error */),
      .syndrome_o(/* unused */),
      .err_o     (acc_intg_err[i_word*2+:2])
    );
    assign acc_no_intg_q[i_word*32+:32] = acc_intg_q[i_word*39+:32];
  end

  always_ff @(posedge clk_i) begin
    if (acc_wr_en) begin
      acc_intg_q <= acc_intg_d;
    end
  end

  ////////////////
  // Register C //
  ////////////////
  logic                           c_wr_en;
  logic [ExtHWLEN-1:0]            c_intg_d;
  logic [ExtHWLEN-1:0]            c_intg_q;
  logic [HWLEN-1:0]               c_no_intg_d;
  logic [HWLEN-1:0]               c_no_intg_q;
  logic [2*BaseWordsPerHWLEN-1:0] c_intg_err;

  for (genvar i_word = 0; i_word < BaseWordsPerHWLEN; i_word++) begin : g_c_words
    prim_secded_inv_39_32_enc i_c_secded_enc (
      .data_i(c_no_intg_d[i_word*32+:32]),
      .data_o(c_intg_d[i_word*39+:39])
    );
    prim_secded_inv_39_32_dec i_c_secded_dec (
      .data_i    (c_intg_q[i_word*39+:39]),
      .data_o    (/* unused because we abort on any integrity error */),
      .syndrome_o(/* unused */),
      .err_o     (c_intg_err[i_word*2+:2])
    );
    assign c_no_intg_q[i_word*32+:32] = c_intg_q[i_word*39+:32];
  end

  always_ff @(posedge clk_i) begin
    if (c_wr_en) begin
      c_intg_q <= c_intg_d;
    end
  end

  //////////////////
  // Register TMP //
  //////////////////
  logic                           tmp_wr_en;
  logic [ExtQWLEN-1:0]            tmp_intg_d;
  logic [ExtQWLEN-1:0]            tmp_intg_q;
  logic [QWLEN-1:0]               tmp_no_intg_d;
  logic [QWLEN-1:0]               tmp_no_intg_q;
  logic [2*BaseWordsPerQWLEN-1:0] tmp_intg_err;

  for (genvar i_word = 0; i_word < BaseWordsPerQWLEN; i_word++) begin : g_tmp_words
    prim_secded_inv_39_32_enc i_tmp_secded_enc (
      .data_i(tmp_no_intg_d[i_word*32+:32]),
      .data_o(tmp_intg_d[i_word*39+:39])
    );
    prim_secded_inv_39_32_dec i_tmp_secded_dec (
      .data_i    (tmp_intg_q[i_word*39+:39]),
      .data_o    (/* unused because we abort on any integrity error */),
      .syndrome_o(/* unused */),
      .err_o     (tmp_intg_err[i_word*2+:2])
    );
    assign tmp_no_intg_q[i_word*32+:32] = tmp_intg_q[i_word*39+:32];
  end

  always_ff @(posedge clk_i) begin
    if (tmp_wr_en) begin
      tmp_intg_q <= tmp_intg_d;
    end
  end


  ////////////////////
  // Input blanking //
  ////////////////////
  logic [WLEN-1:0]    operand_a_blanked;
  logic [WLEN-1:0]    operand_b_blanked;
  logic [ExtWLEN-1:0] ispr_mod_intg_blanked;

  // SEC_CM: DATA_REG_SW.SCA
  prim_blanker #(.Width(WLEN)) u_operand_a_blanker (
    .in_i (operation_i.operand_a),
    .en_i (mac_predec_bignum_i.op_en),
    .out_o(operand_a_blanked)
  );

  // SEC_CM: DATA_REG_SW.SCA
  prim_blanker #(.Width(WLEN)) u_operand_b_blanker (
    .in_i (operation_i.operand_b),
    .en_i (mac_predec_bignum_i.op_en),
    .out_o(operand_b_blanked)
  );

  // SEC_CM: DATA_REG_SW.SCA
  prim_blanker #(.Width(ExtWLEN)) u_mod_blanker (
    .in_i (ispr_mod_intg_i),
    .en_i (mac_predec_bignum_i.is_mod),
    .out_o(ispr_mod_intg_blanked)
  );

  ///////////////////
  // MOD Extractor //
  ///////////////////
  logic [WLEN-1:0]               mod_no_intg;
  logic [2*BaseWordsPerWLEN-1:0] mod_intg_err;

  for (genvar i_word = 0; i_word < BaseWordsPerWLEN; i_word++) begin : g_mod_words
    prim_secded_inv_39_32_dec i_mod_secded_dec (
      .data_i    (ispr_mod_intg_blanked[i_word*39+:39]),
      .data_o    (/* unused because we abort on any integrity error */),
      .syndrome_o(/* unused */),
      .err_o     (mod_intg_err[i_word*2+:2])
    );
    assign mod_no_intg[i_word*32+:32] = ispr_mod_intg_blanked[i_word*39+:32];
  end

  // We create both values (for 16b and 32b) and then select the correct one using the onehot
  // elen signal. This signal contains also a 64b version but we only use the lower 2 bits.
  // !! This requires the onehot encoding to place 16b or 32b always in these bits!
  // TODO: Maybe refactor the onehot to clean this up. Occurs at multiple locations.
  logic [QWLEN-1:0] all_mod_q [NELENMAC-1];
  logic [QWLEN-1:0] mod_q; // The Montgomery modulus q
  logic [QWLEN-1:0] all_mod_R [NELENMAC-1];
  logic [QWLEN-1:0] mod_R; // The Montgomery R constant, R = (-q)^-1 mod 2^ELEN

  // The modulus and constant in stored in the MOD register at:
  // 16b: q @ [15:0], R @ [47:32]
  // 32b: q @ [31:0], R @ [63:32]
  // For the vectorized multiplications we have to replicate the constants
  assign all_mod_q[ModVecElen16]  = {4{mod_no_intg[15:0]}};
  assign all_mod_q[ModVecElen32]  = {2{mod_no_intg[31:0]}};

  assign all_mod_R[ModVecElen16]  = {4{mod_no_intg[47:32]}};
  assign all_mod_R[ModVecElen32]  = {2{mod_no_intg[63:32]}};

  logic [WLEN-1-64:0] unused_mod;
  assign unused_mod = ~mod_no_intg[WLEN-1:64];

  prim_onehot_mux #(
    .Width(QWLEN),
    .Inputs(NELENMAC-1)
  ) u_mod_q_value_mux (
    .clk_i,
    .rst_ni,
    .in_i  (all_mod_q),
    .sel_i (mac_predec_bignum_i.vec_elen_onehot[1:0]),
    .out_o (mod_q)
  );

  prim_onehot_mux #(
    .Width(QWLEN),
    .Inputs(NELENMAC-1)
  ) u_mod_R_value_mux (
    .clk_i,
    .rst_ni,
    .in_i  (all_mod_R),
    .sel_i (mac_predec_bignum_i.vec_elen_onehot[1:0]),
    .out_o (mod_R)
  );

  ///////////////////////////
  // Vectorized multiplier //
  ///////////////////////////

  // Input operand quad word selection
  logic [1:0]       op_a_qw_sel;
  logic [1:0]       op_b_qw_sel;
  logic [QWLEN-1:0] qword_a;
  logic [QWLEN-1:0] qword_b;
  logic [QWLEN-1:0] qword_b_lane;
  logic [QWLEN-1:0] all_qword_b [NELENMAC-1];

  // pick the lane index and replicate
  always_comb begin // TODO: make bound check for lane_index
    all_qword_b[ModVecElen16]  = {4{operand_b_blanked[operation_i.lane_index*16+:16]}};
    all_qword_b[ModVecElen32]  = {2{operand_b_blanked[operation_i.lane_index*32+:32]}};
  end

  prim_onehot_mux #(
    .Width(QWLEN),
    .Inputs(NELENMAC-1)
  ) u_lane_mux (
    .clk_i ,
    .rst_ni,
    .in_i  (all_qword_b),
    .sel_i (mac_predec_bignum_i.vec_elen_onehot[1:0]),
    .out_o (qword_b_lane)
  );

  always_comb begin
    unique case (op_a_qw_sel)
      2'd0: qword_a = operand_a_blanked[QWLEN*0+:QWLEN];
      2'd1: qword_a = operand_a_blanked[QWLEN*1+:QWLEN];
      2'd2: qword_a = operand_a_blanked[QWLEN*2+:QWLEN];
      2'd3: qword_a = operand_a_blanked[QWLEN*3+:QWLEN];
      default: qword_a = '0;
    endcase

    qword_b = '0;
    if ((operation_i.mul_type == MacMulVecLane) ||
        (operation_i.mul_type == MacMulVecModLane)) begin
      qword_b = qword_b_lane;
    end else begin
      unique case (op_b_qw_sel)
        2'd0: qword_b = operand_b_blanked[QWLEN*0+:QWLEN];
        2'd1: qword_b = operand_b_blanked[QWLEN*1+:QWLEN];
        2'd2: qword_b = operand_b_blanked[QWLEN*2+:QWLEN];
        2'd3: qword_b = operand_b_blanked[QWLEN*3+:QWLEN];
        default: qword_b = '0;
      endcase
    end
  end

  // Multiplier operand selection
  logic             mul_op_a_tmp_sel;
  mul_op_b_sel_e    mul_op_b_sel;
  logic [QWLEN-1:0] mul_op_a;
  logic [QWLEN-1:0] mul_op_b;
  logic [HWLEN-1:0] mul_res;

  assign mul_op_a = mul_op_a_tmp_sel ? qword_a : tmp_no_intg_q;

  always_comb begin
    unique case (mul_op_b_sel)
      MulOpB:  mul_op_b = qword_b;
      MulOpR:  mul_op_b = mod_R;
      MulOpq:  mul_op_b = mod_q;
      default: mul_op_b = '0;
    endcase
  end

  // Multiplier is fully blanked. The inputs do not have to be blanked.
  otbn_vec_multiplier u_vec_multiplier (
    .operand_a_i(mul_op_a),
    .operand_b_i(mul_op_b),
    .elen_ctrl_i(mac_predec_bignum_i.vec_mul_elen_ctrl),
    .result_o   (mul_res)
  );

  ///////////////////////////////////////////
  // Vectorized multiplier result handling //
  ///////////////////////////////////////////
  logic             mul_mod_en;
  logic [HWLEN-1:0] mul_res_mod;
  logic [QWLEN-1:0] all_tmp_value [NELENMAC-1];
  logic [QWLEN-1:0] tmp_value;

  // SEC_CM: DATA_REG_SW.SCA
  prim_blanker #(.Width(HWLEN)) u_mul_res_mod_blanker (
    .in_i (mul_res),
    .en_i (mul_mod_en),
    .out_o(mul_res_mod)
  );

  // Montgomery bit selection:
  // Select only the lower ELEN bits of the parallel multiplications
  // For 16b elements we have four computations parallel (for 32b we have two)
  // The 16b multiplication results in a 32b result. This result is stored in register C
  // and the lower ELEN bits of each computation is stored into register TMP.
  always_comb begin
    c_no_intg_d = '0;
    unique case (1'b1)
      sec_wipe_c_urnd_i: c_no_intg_d = urnd_data_i[HWLEN-1:0];
      default:           c_no_intg_d = mul_res_mod;
    endcase
  end

  assign all_tmp_value[ModVecElen16]  = {mul_res_mod[16*6+:16], mul_res_mod[16*4+:16],
                                         mul_res_mod[16*2+:16], mul_res_mod[16*0+:16]};
  assign all_tmp_value[ModVecElen32]  = {mul_res_mod[32*2+:32], mul_res_mod[32*0+:32]};

  prim_onehot_mux #(
    .Width(QWLEN),
    .Inputs(NELENMAC-1)
  ) u_tmp_value_mux (
    .clk_i ,
    .rst_ni,
    .in_i  (all_tmp_value),
    .sel_i (mac_predec_bignum_i.vec_elen_onehot[1:0]),
    .out_o (tmp_value)
  );

  always_comb begin
    tmp_no_intg_d = '0;
    unique case (1'b1)
      sec_wipe_tmp_urnd_i: tmp_no_intg_d = urnd_data_i[QWLEN-1:0];
      default:             tmp_no_intg_d = tmp_value;
    endcase
  end

  // Truncating and blanking for vectorized multiplication without modulo reduction
  logic [HWLEN-1:0] mul_res_blanked;
  logic [QWLEN-1:0] all_mul_res_merger [NELENMAC-1];
  logic [QWLEN-1:0] mul_res_merger;

  // SEC_CM: DATA_REG_SW.SCA
  prim_blanker #(.Width(HWLEN)) u_mul_res_merger_blanker (
    .in_i (mul_res),
    .en_i (mac_predec_bignum_i.mul_merger_en),
    .out_o(mul_res_blanked)
  );

  assign all_mul_res_merger[ModVecElen16]  = {mul_res_blanked[16*6+:16], mul_res_blanked[16*4+:16],
                                              mul_res_blanked[16*2+:16], mul_res_blanked[16*0+:16]};
  assign all_mul_res_merger[ModVecElen32]  = {mul_res_blanked[32*2+:32], mul_res_blanked[32*0+:32]};

  prim_onehot_mux #(
    .Width(QWLEN),
    .Inputs(NELENMAC-1)
  ) u_mul_merger_value_mux (
    .clk_i ,
    .rst_ni,
    .in_i  (all_mul_res_merger),
    .sel_i (mac_predec_bignum_i.vec_elen_onehot[1:0]),
    .out_o (mul_res_merger)
  );

  logic [16+16-1:0] unused_mul_res_blanked;
  assign unused_mul_res_blanked = ~{mul_res_blanked[127:112],
                                    mul_res_blanked[63:48]};

  // Adder operand blanking and extension
  logic             mul_add_en;
  logic [HWLEN-1:0] half_mul_res_add;
  logic [WLEN-1:0]  mul_res_add;
  // SEC_CM: DATA_REG_SW.SCA
  prim_blanker #(.Width(HWLEN)) u_half_mul_res_blanker (
    .in_i (mul_res),
    .en_i (mul_add_en),
    .out_o(half_mul_res_add)
  );

  assign mul_res_add = {{HWLEN{1'b0}}, half_mul_res_add};

  //////////////////////////////////////////////////////////////////
  // Vectorized multiplier result handling regular multiplication //
  //////////////////////////////////////////////////////////////////
  logic [HWLEN-1:0] mul_res_pre_shifted;
  logic [WLEN-1:0]  mul_res_shifted;

  // SEC_CM: DATA_REG_SW.SCA
  prim_blanker #(.Width(HWLEN)) u_mul_res_shift_blanker (
    .in_i (mul_res),
    .en_i (mac_predec_bignum_i.mul_shift_en),
    .out_o(mul_res_pre_shifted)
  );

  // Shift the QWLEN multiply result into a WLEN word before accumulating using the shift amount
  // supplied in the instruction (pre_acc_shift_imm).
  always_comb begin
    mul_res_shifted = '0;

    unique case (operation_i.pre_acc_shift_imm)
      2'd0: mul_res_shifted = {{QWLEN * 2{1'b0}}, mul_res_pre_shifted};
      2'd1: mul_res_shifted = {{QWLEN{1'b0}}, mul_res_pre_shifted, {QWLEN{1'b0}}};
      2'd2: mul_res_shifted = {mul_res_pre_shifted, {QWLEN * 2{1'b0}}};
      2'd3: mul_res_shifted = {mul_res_pre_shifted[63:0], {QWLEN * 3{1'b0}}};
      default: mul_res_shifted = '0;
    endcase
  end

  `ASSERT_KNOWN_IF(PreAccShiftImmKnown, operation_i.pre_acc_shift_imm, mac_en_i)

  //////////////////////
  // Vectorized Adder //
  //////////////////////
  logic             c_add_en;
  logic [HWLEN-1:0] c_blanked;
  logic [WLEN-1:0]  acc_add_blanked;
  logic [WLEN-1:0]  adder_op_a;
  logic [WLEN-1:0]  adder_op_b;
  logic [WLEN-1:0]  adder_result;

  // SEC_CM: DATA_REG_SW.SCA
  prim_blanker #(.Width(HWLEN)) u_reg_c_blanker (
    .in_i (c_no_intg_q),
    .en_i (c_add_en),
    .out_o(c_blanked)
  );

  // SEC_CM: DATA_REG_SW.SCA
  // acc_add_en is so if .Z set in MULQACC (zero_acc) so accumulator reads as 0
  prim_blanker #(.Width(WLEN)) u_acc_add_blanker (
    .in_i (acc_no_intg_q),
    .en_i (mac_predec_bignum_i.acc_add_en),
    .out_o(acc_add_blanked)
  );


  // Here onehot MUXs are not required because:
  // - mul_res_add is blanked
  // - mul_res_pre_shifted comes from a blanked value (mul_res_pre_shifted) which is fed through a
  //   MUX controlled with a predecoded value and all options are static. The signal is just
  //   extended with zeros depending on the MUX control signal.
  assign adder_op_a = mac_predec_bignum_i.is_mod ? {{128{1'b0}}, c_blanked} : mul_res_shifted;
  assign adder_op_b = mac_predec_bignum_i.is_mod ? mul_res_add : acc_add_blanked;

  otbn_vec_adder #(
    .LVLEN(WLEN)
  ) u_vec_adder (
    .operand_a_i       (adder_op_a),
    .operand_b_i       (adder_op_b),
    .operand_b_invert_i(1'b0),
    .carries_in_i      ('0),
    .use_ext_carry_i   (mac_predec_bignum_i.vec_adder_carry_sel),
    .sum_o             (adder_result),
    .carries_out_o     (/* unused */)
  );

  // Addition result handling

  /////////////////////////////////////////////
  // Vectorized adder modulo result handling //
  /////////////////////////////////////////////
  logic             add_mod_en;
  logic [WLEN-1:0]  adder_result_mod;
  logic [QWLEN-1:0] all_montg_r [NELENMAC-1];
  logic [QWLEN-1:0] montg_r;

  prim_blanker #(.Width(WLEN)) u_add_mod_blanker (
    .in_i (adder_result),
    .en_i (add_mod_en),
    .out_o(adder_result_mod)
  );

  // Montgomery upper bit selection
  // Take only the upper ELEN bits of the addition.
  // The result is "r" of the montgomery algorithm
  assign all_montg_r[ModVecElen16]  = {adder_result_mod[16*7+:16], adder_result_mod[16*5+:16],
                                    adder_result_mod[16*3+:16], adder_result_mod[16*1+:16]};
  assign all_montg_r[ModVecElen32]  = {adder_result_mod[32*3+:32], adder_result_mod[32*1+:32]};

  logic [128+16+16-1:0] unused_adder_result_mod;
  assign unused_adder_result_mod = ~{adder_result_mod[255:128],
                                     adder_result_mod[79:64],
                                     adder_result_mod[15:0]};

  prim_onehot_mux #(
    .Width(QWLEN),
    .Inputs(NELENMAC-1)
  ) u_montg_r_value_mux (
    .clk_i,
    .rst_ni,
    .in_i  (all_montg_r),
    .sel_i (mac_predec_bignum_i.vec_elen_onehot[1:0]),
    .out_o (montg_r)
  );

  // Critical path optimization
  // We do not perform the conditional subtraction in the MAC to improve the critical path.
  // The conditional subtraction can be performed in one cycle for all four 64b chunks by using
  // bn.addvm with zero as one input. This requires one cycle more in addition to the 12 cycles
  // spent here. However, we can reduce the critical path and save the area of a 64b vectorized
  // adder.
  logic [QWLEN-1:0] montg_r_cor;
  assign montg_r_cor = montg_r;

  ///////////////////////////////////////////
  // ACC merging for vectorized operations //
  ///////////////////////////////////////////
  logic             acc_merger_en;
  logic [1:0]       acc_qw_sel;
  logic [QWLEN-1:0] acc_new_qw;
  logic [WLEN-1:0]  acc_old;
  logic [WLEN-1:0]  acc_merged;

  // Here a regular MUX is sufficient. The mul_res_merger comes from the u_mul_merger_value_mux
  // which its values gets from mul_res_blanked. And this blanker is only active (passes data
  // through) if we are performing a vectorized multiplication (default or lane). In this case the
  // montg_r_cor is all zero as the input into the reduction circuit is blanked with
  // u_add_mod_blanker. If we do a modulo multiplication the `montg_r_cor` contains the data but
  // mul_res_blanked is blanked as explained.
  assign acc_new_qw = mac_predec_bignum_i.is_mod ? montg_r_cor : mul_res_merger;

  // This blanker is used to zero the ACC register
  prim_blanker #(.Width(WLEN)) u_acc_merger_blanker (
    .in_i (acc_no_intg_q),
    .en_i (acc_merger_en),
    .out_o(acc_old)
  );

  always_comb begin
    unique case(acc_qw_sel)
      2'd0: acc_merged = {acc_old[QWLEN*1+:3*QWLEN], acc_new_qw};
      2'd1: acc_merged = {acc_old[QWLEN*2+:2*QWLEN], acc_new_qw, acc_old[0+:1*QWLEN]};
      2'd2: acc_merged = {acc_old[QWLEN*3+:1*QWLEN], acc_new_qw, acc_old[0+:2*QWLEN]};
      2'd3: acc_merged = {acc_new_qw, acc_old[0+:3*QWLEN]};
      default: acc_merged = '0;
    endcase
  end

  //////////////////////////////////////////////
  // Vectorized adder regular result handling //
  //////////////////////////////////////////////
  logic [WLEN-1:0] adder_result_blanked;
  logic [WLEN-1:0] regular_acc_update_value;

  prim_blanker #(.Width(WLEN)) u_add_res_blanker (
    .in_i (adder_result),
    .en_i (mac_predec_bignum_i.add_res_en),
    .out_o(adder_result_blanked)
  );

  assign regular_acc_update_value = operation_i.shift_acc ?
             {{QWLEN*2{1'b0}}, adder_result_blanked[QWLEN*2+:QWLEN*2]} : adder_result_blanked;

  /////////////////
  // Flag update //
  /////////////////
  // Vectorized operation never updates flags
  logic [1:0] adder_result_hw_is_zero;

  // Split zero check between the two halves of the result. This is used for flag setting (see
  // below).
  assign adder_result_hw_is_zero[0] = adder_result_blanked[WLEN/2-1:0] == 'h0;
  assign adder_result_hw_is_zero[1] = adder_result_blanked[WLEN/2+:WLEN/2] == 'h0;

  assign operation_flags_o.L    = adder_result_blanked[0];
  // L is always updated for .WO, and for .SO when writing to the lower half-word
  assign operation_flags_en_o.L = mac_predec_bignum_i.is_vec ? 1'b0 :
                                       operation_i.shift_acc ? ~operation_i.wr_hw_sel_upper : 1'b1;

  // For .SO M is taken from the top-bit of shifted out half-word, otherwise it is taken from the
  // top-bit of the full result.
  assign operation_flags_o.M    = operation_i.shift_acc ? adder_result_blanked[WLEN/2-1] :
                                                          adder_result_blanked[WLEN-1];
  // M is always updated for .WO, and for .SO when writing to the upper half-word.
  assign operation_flags_en_o.M = mac_predec_bignum_i.is_vec ? 1'b0 :
                                       operation_i.shift_acc ? operation_i.wr_hw_sel_upper : 1'b1;

  // For .SO Z is calculated from the shifted out half-word, otherwise it is calculated on the full
  // result.
  assign operation_flags_o.Z    = operation_i.shift_acc ? adder_result_hw_is_zero[0] :
                                                          &adder_result_hw_is_zero;

  // Z is updated for .WO. For .SO updates are based upon result and half-word:
  // - When writing to lower half-word always update Z.
  // - When writing to upper half-word clear Z if result is non-zero otherwise leave it alone.
  assign operation_flags_en_o.Z = mac_predec_bignum_i.is_vec ? 1'b0 :
         operation_i.shift_acc & operation_i.wr_hw_sel_upper ? ~adder_result_hw_is_zero[0] :
                                                               1'b1;

  // MAC never sets the carry flag
  assign operation_flags_o.C    = 1'b0;
  assign operation_flags_en_o.C = 1'b0;

  ////////////////
  // ACC update //
  ////////////////
  always_comb begin
    acc_no_intg_d = '0;
    unique case (1'b1)
      // Non-encoded inputs have to be encoded before writing to the register.
      sec_wipe_acc_urnd_i: begin
        acc_no_intg_d = urnd_data_i;
        acc_intg_d = acc_intg_calc;
      end
      default: begin
        // If performing an ACC ISPR write the next accumulator value is taken from the ISPR write
        // data, otherwise it is drawn from the adder result or the vectorized ACC merger.
        if (ispr_acc_wr_en_i) begin
          acc_intg_d = ispr_acc_wr_data_intg_i;
        end else begin
          acc_no_intg_d = mac_predec_bignum_i.is_vec ? acc_merged : regular_acc_update_value;
          acc_intg_d = acc_intg_calc;
        end
      end
    endcase
  end

  ///////////////////////////
  // Register Write Enable //
  ///////////////////////////
  // The raw write enables are set by the state machine. These are then combined with the input signals
  // which handle the validity of the instruction.
  logic acc_wr_en_raw;
  logic tmp_wr_en_raw;
  logic c_wr_en_raw;

  // Only write to accumulator if the MAC is enabled or an ACC ISPR write is occuring or secure
  // wipe of the internal state is occuring.
  assign acc_wr_en = (acc_wr_en_raw & (mac_en_i & mac_commit_i))
                     | ispr_acc_wr_en_i | sec_wipe_acc_urnd_i;
  assign tmp_wr_en = (tmp_wr_en_raw & (mac_en_i & mac_commit_i)) | sec_wipe_tmp_urnd_i;
  assign c_wr_en   = (c_wr_en_raw & (mac_en_i & mac_commit_i)) | sec_wipe_c_urnd_i;

  /////////////////
  // Control FSM //
  /////////////////
  // Only advance to next state if we have a go
  logic do_advance;
  assign do_advance = mac_en_i & mac_commit_i;
  logic operation_valid_raw;

  logic expected_mul_shift_en;
  logic expected_mul_merger_en;
  logic expected_add_res_en;

  /**
   * The MAC module implements the following types of MAC:
   * - Regular 64b multiplication with accumulation in ACC
   * - Vectorized Multiplication for 16b or 32b elements of a 256b vector (WDR)
   *   - Either elementwise or multiply each element of vector a with a fixed element
   *     of vector b. The later is hereinafter described as Lane multiplication.
   * - Vectorized Multiplication with modulo reduction (16b or 32b elements)
   *   - Also elementwise or lane mode
   *
   * The different multicycle operations are implemented with a FSM. We always start in
   * the "MacRegular" state. This state however includes also the start state of the four other
   * operations. This is required as the regular multiplication is single cycle. We cycle through
   * all required states where the last state asserts the valid flag. Afterwards we go back to
   * the MacRegular state and prepare for the next operation.
   *
   * Regular multiplication: single cycle, we stay in MacRegular
   * Vectorized: MacRegular -> MacQW1 -> MacQW2 -> MacDoneQW
   * Vectorized Lane: Same as Vectorized but multiplier operator b is fixed
   *
   * Vectorized Modulo: The modulo reduction is implemented with Montgomery. It requires 3 cycles
   *     to process one quarter word (i.e. 4x 16b or 2x 32b elements). Thus the total duration is
   *     12 cycles.
   *     MacRegular -> MacModQW0C1 -> MacModQW0C2 -> ... -> MacModQW3C1 -> MacDoneModQW3C2
   *
   * Vectorized Modulo with lane: Same as vectorized modulo but with fixed operand b selection.
   *
   * Blanking is implemented on the whole datapath. Some control signals are predecoded to reduce
   * SCA leakage. However, some control signals do change depending on the cycle and thus are not
   * predecoded. If required the predecoding could be implemented in this FSM.
   */
  always_comb begin : mac_fsm
    // Default assignments
    mac_state_d = mac_state_q;

    op_a_qw_sel      = 2'd0;
    op_b_qw_sel      = 2'd0;
    acc_qw_sel       = 2'd0;
    mul_op_a_tmp_sel = 1'b1; // select a as it is blanked
    mul_op_b_sel     = MulOpB; // select b as it is blanked
    tmp_wr_en_raw    = 1'b0;
    c_wr_en_raw      = 1'b0;
    acc_wr_en_raw    = 1'b0;
    mul_add_en       = 1'b0;
    mul_mod_en       = 1'b0;
    c_add_en         = 1'b0;
    add_mod_en       = 1'b0;
    acc_merger_en    = 1'b0;

    operation_valid_raw = 1'b0;

    expected_mul_shift_en  = 1'b0;
    expected_mul_merger_en = 1'b0;
    expected_add_res_en    = 1'b0;

    // TODO: Merge similar cases
    unique case (mac_state_q)
      MacRegular: begin
        // Includes states MacStartQW0 and MacStartModQW0C0
        unique case (mac_predec_bignum_i.mul_type) // TODO: make it onehot?
          MacMulRegular: begin
            op_a_qw_sel         = operation_i.operand_a_qw_sel;
            op_b_qw_sel         = operation_i.operand_b_qw_sel;
            acc_wr_en_raw       = 1'b1;
            operation_valid_raw = 1'b1;

            // Only expect the blankers to be active if we are enabled
            expected_mul_shift_en  = 1'b1 & mac_en_i;
            expected_add_res_en    = 1'b1 & mac_en_i;
          end
          MacMulVec,
          MacMulVecLane: begin
            op_a_qw_sel   = 2'd0;
            op_b_qw_sel   = 2'd0; // No effect for Lane
            acc_wr_en_raw = 1'b1; // Clear ACC register to zero
            mac_state_d   = MacQW1;

            // Only expect the blankers to be active if we are enabled
            expected_mul_merger_en = 1'b1 & mac_en_i;
          end
          MacMulVecMod,
          MacMulVecModLane: begin
            op_a_qw_sel   = 2'd0;
            op_b_qw_sel   = 2'd0; // No effect for Lane
            tmp_wr_en_raw = 1'b1;
            c_wr_en_raw   = 1'b1;
            mul_mod_en    = 1'b1;
            mac_state_d   = MacModQW0C1;
          end
          default: mac_state_d = MacError;
        endcase
      end
      MacQW1: begin
        op_a_qw_sel   = 2'd1;
        op_b_qw_sel   = 2'd1; // No effect for Lane
        acc_qw_sel    = 2'd1;
        acc_wr_en_raw = 1'b1;
        acc_merger_en = 1'b1;
        mac_state_d   = MacQW2;

        expected_mul_merger_en = 1'b1;
      end
      MacQW2: begin
        op_a_qw_sel   = 2'd2;
        op_b_qw_sel   = 2'd2; // No effect for Lane
        acc_qw_sel    = 2'd2;
        acc_wr_en_raw = 1'b1;
        acc_merger_en = 1'b1;
        mac_state_d   = MacDoneQW;

        expected_mul_merger_en = 1'b1;
      end
      MacDoneQW: begin
        op_a_qw_sel         = 2'd3;
        op_b_qw_sel         = 2'd3; // No effect for Lane
        acc_qw_sel          = 2'd3;
        acc_wr_en_raw       = 1'b1;
        acc_merger_en       = 1'b1;
        operation_valid_raw = 1'b1;
        mac_state_d         = MacRegular;

        expected_mul_merger_en = 1'b1;
      end
      MacModQW0C1: begin
        op_a_qw_sel      = 2'd0;
        op_b_qw_sel      = 2'd0; // No effect for Lane
        mul_op_a_tmp_sel = 1'b0;
        mul_op_b_sel     = MulOpR;
        tmp_wr_en_raw    = 1'b1;
        mul_mod_en       = 1'b1;
        mac_state_d      = MacModQW0C2;
      end
      MacModQW0C2: begin
        op_a_qw_sel      = 2'd0;
        op_b_qw_sel      = 2'd0; // No effect for Lane
        mul_op_a_tmp_sel = 1'b0;
        mul_op_b_sel     = MulOpq;
        acc_wr_en_raw    = 1'b1;
        mul_add_en       = 1'b1;
        c_add_en         = 1'b1;
        add_mod_en       = 1'b1;
        acc_merger_en    = 1'b0; // Clear ACC
        mac_state_d      = MacModQW1C0;
      end
      MacModQW1C0: begin
        op_a_qw_sel   = 2'd1;
        op_b_qw_sel   = 2'd1; // No effect for Lane
        acc_qw_sel    = 2'd1;
        tmp_wr_en_raw = 1'b1;
        c_wr_en_raw   = 1'b1;
        mul_mod_en    = 1'b1;
        mac_state_d   = MacModQW1C1;
      end
      MacModQW1C1: begin
        op_a_qw_sel      = 2'd1;
        op_b_qw_sel      = 2'd1; // No effect for Lane
        mul_op_a_tmp_sel = 1'b0;
        mul_op_b_sel     = MulOpR;
        acc_qw_sel       = 2'd1;
        tmp_wr_en_raw    = 1'b1;
        mul_mod_en       = 1'b1;
        mac_state_d      = MacModQW1C2;
      end
      MacModQW1C2: begin
        op_a_qw_sel      = 2'd1;
        op_b_qw_sel      = 2'd1; // No effect for Lane
        mul_op_a_tmp_sel = 1'b0;
        mul_op_b_sel     = MulOpq;
        acc_qw_sel       = 2'd1;
        acc_wr_en_raw    = 1'b1;
        mul_add_en       = 1'b1;
        c_add_en         = 1'b1;
        add_mod_en       = 1'b1;
        acc_merger_en    = 1'b1;
        mac_state_d      = MacModQW2C0;
      end
      MacModQW2C0: begin
        op_a_qw_sel      = 2'd2;
        op_b_qw_sel      = 2'd2; // No effect for Lane
        acc_qw_sel       = 2'd2;
        tmp_wr_en_raw    = 1'b1;
        c_wr_en_raw      = 1'b1;
        mul_mod_en       = 1'b1;
        mac_state_d      = MacModQW2C1;
      end
      MacModQW2C1: begin
        op_a_qw_sel      = 2'd2;
        op_b_qw_sel      = 2'd2; // No effect for Lane
        mul_op_a_tmp_sel = 1'b0;
        mul_op_b_sel     = MulOpR;
        acc_qw_sel       = 2'd2;
        tmp_wr_en_raw    = 1'b1;
        mul_mod_en       = 1'b1;
        mac_state_d      = MacModQW2C2;
      end
      MacModQW2C2: begin
        op_a_qw_sel      = 2'd2;
        op_b_qw_sel      = 2'd2; // No effect for Lane
        mul_op_a_tmp_sel = 1'b0;
        mul_op_b_sel     = MulOpq;
        acc_qw_sel       = 2'd2;
        acc_wr_en_raw    = 1'b1;
        mul_add_en       = 1'b1;
        c_add_en         = 1'b1;
        add_mod_en       = 1'b1;
        acc_merger_en    = 1'b1;
        mac_state_d      = MacModQW3C0;
      end
      MacModQW3C0: begin
        op_a_qw_sel      = 2'd3;
        op_b_qw_sel      = 2'd3; // No effect for Lane
        acc_qw_sel       = 2'd3;
        tmp_wr_en_raw    = 1'b1;
        c_wr_en_raw      = 1'b1;
        mul_mod_en       = 1'b1;
        mac_state_d      = MacModQW3C1;
      end
      MacModQW3C1: begin
        op_a_qw_sel      = 2'd3;
        op_b_qw_sel      = 2'd3; // No effect for Lane
        mul_op_a_tmp_sel = 1'b0;
        mul_op_b_sel     = MulOpR;
        acc_qw_sel       = 2'd3;
        tmp_wr_en_raw    = 1'b1;
        mul_mod_en       = 1'b1;
        mac_state_d      = MacDoneModQW3C2;
      end
      MacDoneModQW3C2: begin
        op_a_qw_sel         = 2'd3;
        op_b_qw_sel         = 2'd3; // No effect for Lane
        mul_op_a_tmp_sel    = 1'b0;
        mul_op_b_sel        = MulOpq;
        acc_qw_sel          = 2'd3;
        acc_wr_en_raw       = 1'b1;
        mul_add_en          = 1'b1;
        c_add_en            = 1'b1;
        add_mod_en          = 1'b1;
        acc_merger_en       = 1'b1;
        mac_state_d         = MacRegular;
        operation_valid_raw = 1'b1;
      end
      MacError: mac_state_d = MacError; // TODO: trigger alarm
      default: mac_state_d = MacError; // Consider triggering an error or alert in this case.
    endcase
    // Reset assigned state change if we are not allowed to advance except in error case
    if (!do_advance && (mac_state_d != MacError)) begin
      mac_state_d = mac_state_q;
    end
  end

  `PRIM_FLOP_SPARSE_FSM(u_mac_state_regs, mac_state_d, mac_state_q, mac_state_e, MacRegular)

  //////////////////////
  // Result selection //
  //////////////////////
  // Regular: The operation result is taken directly from the adder, shift_acc only applies to the new value
  // written to the accumulator.
  // Vectorized: All results are stored in ACC
  assign operation_result_o = mac_predec_bignum_i.is_vec ? acc_merged : adder_result_blanked;
  assign operation_valid_o  = operation_valid_raw & mac_en_i;

  /////////////////////
  // Integrity error //
  /////////////////////
  // Propagate integrity error only if a register is used and MAC is enabled
  logic tmp_used;
  logic c_used;
  logic mod_used;
  logic acc_used;
  // TMP is used if multiplier operand a is set to TMP
  assign tmp_used = mac_en_i && (!mul_op_a_tmp_sel);
  // c is used if its blanker is enabled
  assign c_used = mac_en_i & c_add_en;
  // MOD is used if modulo operation is active
  assign mod_used = mac_en_i &&
      ((operation_i.mul_type == MacMulVecMod) || (operation_i.mul_type == MacMulVecModLane));
  // The ACC is used if we do not reset it or require it to merge the current quarter word
  assign acc_used = mac_en_i && (acc_merger_en ||
      ((operation_i.mul_type == MacMulRegular) && ~operation_i.zero_acc));

  assign operation_intg_violation_err_o = (tmp_used & |(tmp_intg_err)) ||
                                          (c_used   & |(c_intg_err))   ||
                                          (mod_used & |(mod_intg_err)) ||
                                          (acc_used & |(acc_intg_err));

  //////////////////////
  // Redundancy check //
  //////////////////////
  logic                expected_op_en;
  logic [NELENMAC-1:0] expected_vec_elen_onehot;
  mac_mul_type_e       expected_mul_type;
  logic                expected_is_mod;
  logic                expected_is_vec;
  logic                expected_acc_add_en;
  // TODO: decode these also in otbn_decoder.sv
  // logic [NELENMAC-1:0] expected_vec_adder_carry_sel;
  // logic [3:0]          expected_vec_sub_carry_sel;
  // logic [NELENMAC-1:0] expected_vec_mul_elen_ctrl;

  // SEC_CM: CTRL.REDUN
  assign expected_op_en           = mac_en_i;
  assign expected_vec_elen_onehot = operation_i.vec_elen_onehot;
  assign expected_mul_type        = operation_i.mul_type;
  assign expected_is_mod          = (operation_i.mul_type == MacMulVecMod) ||
                                    (operation_i.mul_type == MacMulVecModLane);
  assign expected_is_vec          = (operation_i.mul_type == MacMulVecMod) ||
                                    (operation_i.mul_type == MacMulVecModLane) ||
                                    (operation_i.mul_type == MacMulVec) ||
                                    (operation_i.mul_type == MacMulVecLane);
  assign expected_acc_add_en      = ~operation_i.zero_acc & mac_en_i &
                                    (operation_i.mul_type == MacMulRegular);

  assign predec_error_o = |{expected_op_en           != mac_predec_bignum_i.op_en,
                            expected_vec_elen_onehot != mac_predec_bignum_i.vec_elen_onehot,
                            expected_mul_type        != mac_predec_bignum_i.mul_type,
                            expected_is_mod          != mac_predec_bignum_i.is_mod,
                            expected_is_vec          != mac_predec_bignum_i.is_vec,
                            expected_acc_add_en      != mac_predec_bignum_i.acc_add_en,
                            expected_mul_shift_en    != mac_predec_bignum_i.mul_shift_en,
                            expected_mul_merger_en   != mac_predec_bignum_i.mul_merger_en,
                            expected_add_res_en      != mac_predec_bignum_i.add_res_en};

  /////////////////////////////////////
  // Register and secure wipe output //
  /////////////////////////////////////
  assign ispr_acc_intg_o = acc_intg_q;

  assign sec_wipe_err_o = (sec_wipe_acc_urnd_i || sec_wipe_tmp_urnd_i || sec_wipe_c_urnd_i) &
                          ~sec_wipe_running_i;

  `ASSERT(NoISPRAccWrAndMacEn, ~(ispr_acc_wr_en_i & mac_en_i))
endmodule
